import datetime
import multiprocessing
from typing import Dict, List, Tuple, Union
import pyinform
import pandas as pd
import numpy as np

from .data_manager import DataManager


def compute_super_class_timeseries(in_class_to_timeseries):
    superclass_to_timeseries = {"T": np.array(np.logical_or(in_class_to_timeseries["TF"], in_class_to_timeseries["TM"]),
                                              dtype=np.int32),
                                "U": np.array(np.logical_or(in_class_to_timeseries["UF"], in_class_to_timeseries["UM"]),
                                              dtype=np.int32),
                                "F": np.array(np.logical_or(in_class_to_timeseries["TF"], in_class_to_timeseries["UF"]),
                                              dtype=np.int32),
                                "M": np.array(np.logical_or(in_class_to_timeseries["TM"], in_class_to_timeseries["UM"]),
                                              dtype=np.int32)}
    superclass_to_timeseries["*"] = np.array(np.logical_or(superclass_to_timeseries["T"], superclass_to_timeseries["U"]), dtype=np.int32)
    return superclass_to_timeseries


def get_actor_time_series(in_actor_id: str, in_data_manager: DataManager, in_datetime_index: pd.DatetimeIndex,
                          in_frequency) -> Dict[str, np.ndarray]:
    """
    Given an actor_id returns the timeseries for each class for the actor.
    Parameters
    ----------
    in_actor_id :
        The actor_id
    in_frequency :
        Frequency stirng. examples: 'D', '6H'
    in_datetime_index :
        A datetime index generated by pd.date_range for fixing the index and length issues due to data variations.
    in_data_manager :
        The DataManager object that provides all required data.
    Returns
    -------
        Dictionary containing timeseries of the actor for each class.
    """
    print(f" E:{in_actor_id} ")
    actor_events_df = in_data_manager.get_actors_msgs(in_actor_id, True)
    class_to_timeseries = {}
    for this_class in ["TF", "TM", "UF", "UM"]:
        class_column = f"class_{this_class}"
        actors_binary_timeseries = actor_events_df[actor_events_df[class_column] > 0].set_index(
            "datetime").resample(in_frequency).size().apply(lambda x: 1 if x > 0 else 0).rename("events").reindex(
            in_datetime_index, fill_value=0).values
        class_to_timeseries[this_class] = actors_binary_timeseries
    class_to_timeseries.update(compute_super_class_timeseries(class_to_timeseries))
    class_to_timeseries["all"] = actor_events_df.set_index("datetime").resample(in_frequency).size().apply(
        lambda x: 1 if x > 0 else 0).rename("events").reindex(in_datetime_index, fill_value=0).values
    return class_to_timeseries


def calculate_transfer_entropy_data(in_src_idx: int, in_src_actor_id: str, in_tgt_idx: int, in_tgt_actor_id: str,
                                    in_comparison_pairs_list: List[Tuple[str]],
                                    in_actor_timeseries_dict_list: List[Dict[str, np.ndarray]]) -> List[Union[str, float]]:
    print(f" {in_src_idx}->{in_tgt_idx} ")
    te_values_list = [pyinform.transfer_entropy(in_actor_timeseries_dict_list[in_src_idx][src_class],
                                                in_actor_timeseries_dict_list[in_tgt_idx][tgt_class], 1) for
                      src_class, tgt_class in in_comparison_pairs_list]
    data_row = [in_src_actor_id, in_tgt_actor_id]
    data_row.extend(te_values_list)
    return data_row


class TransferEntropyCalculator:

    def __init__(self, in_data_manager: DataManager, in_classes: List[str] = None):
        if in_classes is None:
            in_classes = ["TF", "TM", "UF", "UM", "T", "U", "F", "M", "*", "all"]
        self.data_manager = in_data_manager
        self.start_date = None
        self.end_date = None
        self.frequency = None
        self.datetime_index = None
        self.__init_comparison_pairs_list(in_classes)

    def calculate_te_network(self, in_start_date: datetime.datetime, in_end_date: datetime.datetime, in_frequency: str):
        self.start_date = in_start_date
        self.end_date = in_end_date
        self.frequency = in_frequency
        self.datetime_index = pd.date_range(start=self.start_date, end=self.end_date, freq=self.frequency)

        self.data_manager.filter_osn_msgs_view(self.start_date, self.end_date)

        print("calculating actor timeseries dictionaries...")
        actor_timeseries_dict_list = self.__calculate_actor_to_timeseries_dict_list()
        print("calculating te sets...")
        all_te_data = self.__calculate_transfer_entropy_sets(actor_timeseries_dict_list)
        print("creating dataframe...")
        return pd.DataFrame(all_te_data,
                            columns=["Source", "Target"] + [f"{src}_{tgt}" for src, tgt in self.comparison_pairs_list])

    def __init_comparison_pairs_list(self, in_classes: List[str]):
        self.comparison_pairs_list = []
        # c = 0
        for src in in_classes:
            for tgt in in_classes:
                if (src in {"*", "all"} and tgt in {"*", "all"}) or \
                        (src in {"T", "U"} and tgt in {"T", "U"}) or  \
                        (src in {"F", "M"} and tgt in {"F", "M"}) or \
                        (src in {"TF", "TM", "UF", "UM"} and tgt in {"TF", "TM", "UF", "UM"}):
                    self.comparison_pairs_list.append((src, tgt))
                    # print(c, src, tgt, f"{src}->{tgt}")
                    # c += 1

    def __calculate_transfer_entropy_sets(self, in_actor_timeseries_dict_list: List[Dict[str, np.ndarray]]):
        params_list = [[src_idx, self.data_manager.actors_df.index[src_idx],
                        tgt_idx, self.data_manager.actors_df.index[tgt_idx],
                        self.comparison_pairs_list, in_actor_timeseries_dict_list]
                       for src_idx in range(self.data_manager.actors_df.shape[0])
                       for tgt_idx in range(self.data_manager.actors_df.shape[0])
                       if src_idx != tgt_idx]
        with multiprocessing.Pool(multiprocessing.cpu_count() - 1) as p:
            results = p.starmap(calculate_transfer_entropy_data, params_list)
        return results

    def __calculate_actor_to_timeseries_dict_list(self) -> List[Dict[str, np.ndarray]]:
        """
        Calculates a list of dictionaries.
        Order of the list is correspondent to the index of actors_df of DataManager
        Each dictionary is an output of the get_actor_time_series function.
        Returns
        -------
            A list containing the timeseries dicts of each actor
        """
        params_list = [[actor_id, self.data_manager, self.datetime_index, self.frequency]
                       for actor_id in self.data_manager.actors_df.index]
        with multiprocessing.Pool(multiprocessing.cpu_count() - 1) as p:
            results = p.starmap(get_actor_time_series, params_list)
        return results
